import { getAllBuffalos } from "@/services/buffaloService"
import { getAllLactations } from "@/services/lactationService"
import { getAllProductions } from "@/services/productionService"
import { getAllUsers } from "@/services/userService"

// Fun√ß√£o para buscar e processar estat√≠sticas dos b√∫falos
export async function fetchBuffaloStats() {
  try {
    const buffalos = await getAllBuffalos()

    const activeBuffalos = buffalos.filter(
      (buffalo) =>
        buffalo.atividade &&
        buffalo.atividade.length > 0 &&
        buffalo.atividade[buffalo.atividade.length - 1].status === "Ativa",
    )

    const females = activeBuffalos.filter((buffalo) => buffalo.sexo === "F√™mea")
    const males = activeBuffalos.filter((buffalo) => buffalo.sexo === "Macho")

    return {
      total: activeBuffalos.length,
      females: females.length,
      males: males.length,
      activeBuffalos,
    }
  } catch (error) {
    console.error("‚ùå Erro ao buscar estat√≠sticas dos b√∫falos:", error)
    return {
      total: 0,
      females: 0,
      males: 0,
      activeBuffalos: [],
    }
  }
}

// Fun√ß√£o para buscar dados de funcion√°rios - CORRIGIDA para mostrar total de usu√°rios
export async function fetchEmployeeCount() {
  try {
    const users = await getAllUsers()
    console.log("üìä Dados de usu√°rios recebidos:", users)

    // Verificar se users √© um array
    if (!Array.isArray(users)) {
      console.error("‚ùå Users n√£o √© um array:", users)
      return 0
    }

    // Retornar o total de usu√°rios em vez de filtrar por funcion√°rios
    console.log(`‚úÖ Total de usu√°rios encontrados: ${users.length}`)

    // Log para debug - mostrar todos os cargos
    users.forEach((user, index) => {
      console.log(`üë§ Usu√°rio ${index + 1}:`, user.nome, "Cargo:", user.cargo)
    })

    return users.length
  } catch (error) {
    console.error("‚ùå Erro ao buscar funcion√°rios:", error)
    return 0
  }
}

// Fun√ß√£o para processar dados de lacta√ß√£o para gr√°ficos de produ√ß√£o
export async function fetchLactationData() {
  try {
    const lactationResponse = await getAllLactations()

    // Verifica√ß√£o adicional de seguran√ßa
    if (!lactationResponse || !lactationResponse.lactations) {
      console.log("‚ö†Ô∏è fetchLactationData: Nenhum dado de lacta√ß√£o dispon√≠vel")
      return {
        weekly: generateEmptyWeeklyData(),
        monthly: generateEmptyMonthlyData(),
        yearly: generateEmptyYearlyData(),
      }
    }

    const lactations = lactationResponse.lactations

    // Processar dados para gr√°ficos semanais, mensais e anuais
    const processedData = {
      weekly: processWeeklyLactation(lactations),
      monthly: processMonthlyLactation(lactations),
      yearly: processYearlyLactation(lactations),
    }

    return processedData
  } catch (error) {
    console.error("‚ùå Erro ao buscar dados de lacta√ß√£o:", error)
    return {
      weekly: generateEmptyWeeklyData(),
      monthly: generateEmptyMonthlyData(),
      yearly: generateEmptyYearlyData(),
    }
  }
}

// Fun√ß√£o para buscar top b√∫falas produtoras - ATUALIZADA
export async function fetchTopBuffalos() {
  try {
    const lactationResponse = await getAllLactations()

    // Verifica√ß√£o adicional de seguran√ßa
    if (!lactationResponse || !lactationResponse.lactations) {
      console.log("‚ö†Ô∏è fetchTopBuffalos: Nenhum dado de lacta√ß√£o dispon√≠vel")
      return { buffalos: [], count: 0 }
    }

    const lactations = lactationResponse.lactations
    const buffalos = await getAllBuffalos()

    // Se n√£o h√° lacta√ß√µes, retornar array vazio
    if (lactations.length === 0) {
      console.log("‚ö†Ô∏è fetchTopBuffalos: Array de lacta√ß√µes vazio")
      return { buffalos: [], count: 0 }
    }

    // Calcular produ√ß√£o m√©dia por b√∫fala
    const buffaloProduction = {}

    lactations.forEach((lactation) => {
      if (lactation.metrica && lactation.metrica.length > 0 && lactation.tagBufala) {
        const totalProduction = lactation.metrica.reduce((sum, metric) => {
          return sum + (metric.quantidade || 0)
        }, 0)

        const avgProduction = totalProduction / lactation.metrica.length

        if (!buffaloProduction[lactation.tagBufala]) {
          buffaloProduction[lactation.tagBufala] = []
        }
        buffaloProduction[lactation.tagBufala].push(avgProduction)
      }
    })

    // Calcular m√©dia final e criar ranking
    const rankings = Object.entries(buffaloProduction).map(([tag, productions]) => {
      const avgProduction = productions.reduce((sum, prod) => sum + prod, 0) / productions.length
      const buffalo = buffalos.find((b) => b.tag === tag)

      return {
        name: buffalo?.nome || tag,
        tag: tag,
        leite: Math.round(avgProduction * 10) / 10, // Arredondar para 1 casa decimal
      }
    })

    // Ordenar por produ√ß√£o e pegar top 10
    const topBuffalos = rankings.sort((a, b) => b.leite - a.leite).slice(0, 10)

    return {
      buffalos: topBuffalos,
      count: topBuffalos.length,
    }
  } catch (error) {
    console.error("‚ùå Erro ao buscar top b√∫falas:", error)
    return { buffalos: [], count: 0 }
  }
}

// Fun√ß√£o para buscar dados de produ√ß√£o/vendas - CORRIGIDA com verifica√ß√£o de null
export async function fetchProductionSalesData() {
  try {
    const productions = await getAllProductions()
    console.log("üìä Dados de produ√ß√µes recebidos:", productions)

    // Verificar se productions √© um array v√°lido
    if (!Array.isArray(productions) || productions.length === 0) {
      console.log("‚ö†Ô∏è fetchProductionSalesData: Nenhum dado de produ√ß√£o dispon√≠vel")
      return {
        lastCollection: { amount: 0, date: null },
        pricePerLiter: 0,
        estimatedRevenue: 0,
        totalProduced: 0,
        currentStock: 0,
      }
    }

    // Calcular totais de produ√ß√£o
    const totalProduced = productions.reduce((sum, production) => {
      return sum + (production.totalProduzido || 0)
    }, 0)

    const currentStock = productions.reduce((sum, production) => {
      return sum + (production.estoqueAtual || 0)
    }, 0)

    console.log("üìä Total produzido:", totalProduced, "Estoque atual:", currentStock)

    // Buscar √∫ltima coleta (PRIORIDADE PARA COLETAS REAIS)
    const allCollections = []
    productions.forEach((production) => {
      if (production.coletas && production.coletas.length > 0) {
        production.coletas.forEach((coleta) => {
          allCollections.push({
            ...coleta,
            date: new Date(coleta.dataColeta),
            isRealCollection: true, // Marcar como coleta real
          })
        })
      }
    })

    console.log("üìä Coletas encontradas:", allCollections.length)

    let lastCollection = { amount: 0, date: null }
    let avgPricePerLiter = 0
    let estimatedRevenue = 0

    if (allCollections.length > 0) {
      // TEM COLETAS REAIS - usar dados de coleta
      allCollections.sort((a, b) => b.date - a.date)
      lastCollection = {
        amount: allCollections[0]?.quantidadeColetada || 0,
        date: allCollections[0]?.date || null,
      }

      console.log("üìä √öltima coleta (real):", lastCollection)

      // Calcular pre√ßo m√©dio por litro
      const totalValue = allCollections.reduce((sum, coleta) => {
        const value = Number.parseFloat(coleta.valorPago?.replace(/[^\d,]/g, "").replace(",", ".")) || 0
        return sum + value
      }, 0)

      const totalQuantity = allCollections.reduce((sum, coleta) => {
        return sum + (coleta.quantidadeColetada || 0)
      }, 0)

      avgPricePerLiter = totalQuantity > 0 ? totalValue / totalQuantity : 3.5

      // Estimar faturamento mensal (baseado na m√©dia dos √∫ltimos 30 dias)
      const thirtyDaysAgo = new Date()
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)

      const recentCollections = allCollections.filter((coleta) => coleta.date >= thirtyDaysAgo)
      const monthlyQuantity = recentCollections.reduce((sum, coleta) => {
        return sum + (coleta.quantidadeColetada || 0)
      }, 0)

      estimatedRevenue = monthlyQuantity * avgPricePerLiter
    } else {
      // N√ÉO TEM COLETAS - usar dados de produ√ß√£o como fallback
      console.log("‚ö†Ô∏è Nenhuma coleta encontrada, usando dados de produ√ß√£o")

      // Buscar a produ√ß√£o mais recente
      const productionsWithDates = productions
        .filter((p) => p.dataAtualizacao)
        .sort((a, b) => new Date(b.dataAtualizacao) - new Date(a.dataAtualizacao))

      if (productionsWithDates.length > 0) {
        lastCollection = {
          amount: productionsWithDates[0].totalProduzido || 0,
          date: new Date(productionsWithDates[0].dataAtualizacao),
        }
        console.log("üìä √öltima coleta (produ√ß√£o):", lastCollection)
      }

      // Pre√ßo estimado baseado em m√©dia de mercado
      avgPricePerLiter = 3.5 // Valor padr√£o
      estimatedRevenue = currentStock * avgPricePerLiter
    }

    const result = {
      lastCollection,
      pricePerLiter: avgPricePerLiter,
      estimatedRevenue,
      totalProduced,
      currentStock,
    }

    console.log("üìä Resultado final fetchProductionSalesData:", result)
    return result
  } catch (error) {
    console.error("‚ùå Erro ao buscar dados de produ√ß√£o/vendas:", error)
    return {
      lastCollection: { amount: 0, date: null },
      pricePerLiter: 0,
      estimatedRevenue: 0,
      totalProduced: 0,
      currentStock: 0,
    }
  }
}

// Fun√ß√£o para gerar dados do gr√°fico produ√ß√£o vs coleta - CORRIGIDA E MELHORADA
export async function fetchProductionVsCollectionData() {
  try {
    const lactationResponse = await getAllLactations()
    const productions = await getAllProductions()

    console.log("üìä Dados para gr√°fico - Lacta√ß√µes:", lactationResponse, "Produ√ß√µes:", productions)

    // Processar dados por m√™s
    const monthlyData = {}

    // 1. PROCESSAR LACTA√á√ïES (Produ√ß√£o individual por b√∫fala)
    if (lactationResponse && lactationResponse.lactations && lactationResponse.lactations.length > 0) {
      const lactations = lactationResponse.lactations
      console.log("üìä Processando lacta√ß√µes:", lactations.length)

      lactations.forEach((lactation) => {
        if (lactation.metrica && lactation.metrica.length > 0) {
          lactation.metrica.forEach((metric) => {
            if (metric.dataMedida && metric.quantidade) {
              const date = new Date(metric.dataMedida)
              const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`

              if (!monthlyData[monthKey]) {
                monthlyData[monthKey] = { producao: 0, coleta: 0 }
              }

              monthlyData[monthKey].producao += metric.quantidade
              console.log(`üìä Lacta√ß√£o adicionada: ${monthKey} - ${metric.quantidade}L`)
            }
          })
        }
      })
    }

    // 2. PROCESSAR PRODU√á√ïES (Dados de produ√ß√£o total e coletas)
    if (Array.isArray(productions) && productions.length > 0) {
      console.log("üìä Processando produ√ß√µes:", productions.length)

      productions.forEach((production) => {
        // 2a. Processar dados de produ√ß√£o individual (quantidadeAdicao)
        if (production.producao && production.producao.length > 0) {
          production.producao.forEach((prod) => {
            if (prod.dataAtualizacao && prod.quantidadeAdicao) {
              const prodDate = new Date(prod.dataAtualizacao)
              const prodMonthKey = `${prodDate.getFullYear()}-${String(prodDate.getMonth() + 1).padStart(2, "0")}`

              if (!monthlyData[prodMonthKey]) {
                monthlyData[prodMonthKey] = { producao: 0, coleta: 0 }
              }

              monthlyData[prodMonthKey].producao += prod.quantidadeAdicao
              console.log(`üìä Produ√ß√£o adicionada: ${prodMonthKey} - ${prod.quantidadeAdicao}L`)
            }
          })
        }

        // 2b. Processar coletas REAIS
        if (production.coletas && production.coletas.length > 0) {
          production.coletas.forEach((coleta) => {
            if (coleta.dataColeta && coleta.quantidadeColetada) {
              const date = new Date(coleta.dataColeta)
              const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`

              if (!monthlyData[monthKey]) {
                monthlyData[monthKey] = { producao: 0, coleta: 0 }
              }

              monthlyData[monthKey].coleta += coleta.quantidadeColetada
              console.log(`üìä Coleta adicionada: ${monthKey} - ${coleta.quantidadeColetada}L`)
            }
          })
        }

        // 2c. Se n√£o h√° coletas, usar totalProduzido como refer√™ncia de "coleta potencial"
        if (
          (!production.coletas || production.coletas.length === 0) &&
          production.totalProduzido &&
          production.dataAtualizacao
        ) {
          const date = new Date(production.dataAtualizacao)
          const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`

          if (!monthlyData[monthKey]) {
            monthlyData[monthKey] = { producao: 0, coleta: 0 }
          }

          // Usar uma porcentagem do total produzido como "coleta estimada"
          const estimatedCollection = production.totalProduzido * 0.9 // 90% do produzido
          monthlyData[monthKey].coleta += estimatedCollection
          console.log(
            `üìä Coleta estimada adicionada: ${monthKey} - ${estimatedCollection}L (90% de ${production.totalProduzido}L)`,
          )
        }
      })
    }

    console.log("üìä Dados mensais processados:", monthlyData)

    // 3. CONVERTER PARA ARRAY E ORDENAR
    const sortedData = Object.entries(monthlyData)
      .sort(([a], [b]) => a.localeCompare(b))
      .slice(-12) // √öltimos 12 meses
      .map(([monthKey, data]) => {
        const [year, month] = monthKey.split("-")
        const monthNames = ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"]

        return {
          month: monthNames[Number.parseInt(month) - 1],
          producao: Math.round(data.producao),
          coleta: Math.round(data.coleta),
        }
      })

    console.log("üìä Dados finais do gr√°fico produ√ß√£o vs coleta:", sortedData)

    // 4. Se n√£o h√° dados, gerar dados de exemplo para visualiza√ß√£o
    if (sortedData.length === 0) {
      console.log("‚ö†Ô∏è Nenhum dado encontrado, gerando dados de exemplo")
      const currentDate = new Date()
      const exampleData = []

      for (let i = 11; i >= 0; i--) {
        const date = new Date(currentDate.getFullYear(), currentDate.getMonth() - i, 1)
        const monthNames = ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"]

        exampleData.push({
          month: monthNames[date.getMonth()],
          producao: Math.floor(Math.random() * 1000) + 500, // 500-1500L
          coleta: Math.floor(Math.random() * 800) + 400, // 400-1200L
        })
      }

      return exampleData
    }

    return sortedData
  } catch (error) {
    console.error("‚ùå Erro ao buscar dados de produ√ß√£o vs coleta:", error)
    return []
  }
}

// Fun√ß√µes para gerar dados vazios quando n√£o h√° informa√ß√µes
function generateEmptyWeeklyData() {
  const weekDays = ["Segunda", "Ter√ßa", "Quarta", "Quinta", "Sexta", "S√°bado", "Domingo"]
  return weekDays.map((day) => ({ name: day, uv: 0 }))
}

function generateEmptyMonthlyData() {
  return [
    { name: "Semana 1", uv: 0 },
    { name: "Semana 2", uv: 0 },
    { name: "Semana 3", uv: 0 },
    { name: "Semana 4", uv: 0 },
  ]
}

function generateEmptyYearlyData() {
  const months = ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"]
  return months.map((month) => ({ name: month, uv: 0 }))
}

// Fun√ß√µes auxiliares para processar dados de lacta√ß√£o
function processWeeklyLactation(lactations) {
  const weekDays = ["Segunda", "Ter√ßa", "Quarta", "Quinta", "Sexta", "S√°bado", "Domingo"]
  const weeklyData = weekDays.map((day) => ({ name: day, uv: 0, count: 0 }))

  lactations.forEach((lactation) => {
    if (lactation.metrica) {
      lactation.metrica.forEach((metric) => {
        if (metric.dataMedida) {
          const date = new Date(metric.dataMedida)
          const dayIndex = date.getDay() === 0 ? 6 : date.getDay() - 1 // Ajustar domingo

          if (dayIndex >= 0 && dayIndex < 7) {
            weeklyData[dayIndex].uv += metric.quantidade || 0
            weeklyData[dayIndex].count += 1
          }
        }
      })
    }
  })

  // Calcular m√©dia
  return weeklyData.map((day) => ({
    ...day,
    uv: day.count > 0 ? Math.round(day.uv / day.count) : 0,
  }))
}

function processMonthlyLactation(lactations) {
  const monthlyData = [
    { name: "Semana 1", uv: 0, count: 0 },
    { name: "Semana 2", uv: 0, count: 0 },
    { name: "Semana 3", uv: 0, count: 0 },
    { name: "Semana 4", uv: 0, count: 0 },
  ]

  lactations.forEach((lactation) => {
    if (lactation.metrica) {
      lactation.metrica.forEach((metric) => {
        if (metric.dataMedida) {
          const date = new Date(metric.dataMedida)
          const weekOfMonth = Math.ceil(date.getDate() / 7) - 1

          if (weekOfMonth >= 0 && weekOfMonth < 4) {
            monthlyData[weekOfMonth].uv += metric.quantidade || 0
            monthlyData[weekOfMonth].count += 1
          }
        }
      })
    }
  })

  return monthlyData.map((week) => ({
    ...week,
    uv: week.count > 0 ? Math.round(week.uv / week.count) : 0,
  }))
}

function processYearlyLactation(lactations) {
  const months = ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"]
  const yearlyData = months.map((month) => ({ name: month, uv: 0, count: 0 }))

  lactations.forEach((lactation) => {
    if (lactation.metrica) {
      lactation.metrica.forEach((metric) => {
        if (metric.dataMedida) {
          const date = new Date(metric.dataMedida)
          const monthIndex = date.getMonth()

          yearlyData[monthIndex].uv += metric.quantidade || 0
          yearlyData[monthIndex].count += 1
        }
      })
    }
  })

  return yearlyData.map((month) => ({
    ...month,
    uv: month.count > 0 ? Math.round(month.uv / month.count) : 0,
  }))
}
